{
  "version": 3,
  "sources": ["../bundle-jEFwqU/checked-fetch.js", "../../../src/lib/station-repository.ts", "../../../src/lib/detection-log-repository.ts", "../../../src/lib/detection-rules-repository.ts", "../../../src/lib/validation.ts", "../../../src/lib/checklist.ts", "../../../src/lib/mock-detection.ts", "../../../src/worker.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-jEFwqU/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-jEFwqU/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/chilumbam/heysalad-qc/.wrangler/tmp/dev-QDiEZx",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "/**\n * HeySalad QC - Station Repository\n * \n * Implements CRUD operations for stations using D1 database.\n * Handles UUID generation and timestamp management.\n * Requirements: 1.1, 1.3, 1.4, 7.2, 7.5\n */\n\nimport type { Station, CreateStationInput, UpdateStationInput } from '../types';\n\n/**\n * Generates a UUID v4 string\n */\nexport function generateUUID(): string {\n  return crypto.randomUUID();\n}\n\n/**\n * Gets current ISO timestamp\n */\nexport function getCurrentTimestamp(): string {\n  return new Date().toISOString();\n}\n\n/**\n * Station repository for D1 database operations\n */\nexport class StationRepository {\n  private db: D1Database;\n\n  constructor(db: D1Database) {\n    this.db = db;\n  }\n\n  /**\n   * List all stations\n   * Requirements: 5.1\n   */\n  async list(): Promise<Station[]> {\n    const result = await this.db\n      .prepare('SELECT * FROM stations ORDER BY created_at DESC')\n      .all<Station>();\n    \n    return result.results || [];\n  }\n\n  /**\n   * Get a station by ID\n   * Requirements: 5.1\n   */\n  async getById(id: string): Promise<Station | null> {\n    const result = await this.db\n      .prepare('SELECT * FROM stations WHERE id = ?')\n      .bind(id)\n      .first<Station>();\n    \n    return result || null;\n  }\n\n  /**\n   * Create a new station\n   * Requirements: 1.1, 5.2, 7.2\n   */\n  async create(input: CreateStationInput): Promise<Station> {\n    const id = generateUUID();\n    const now = getCurrentTimestamp();\n    \n    const station: Station = {\n      id,\n      name: input.name,\n      type: input.type,\n      location: input.location ?? null,\n      description: input.description ?? null,\n      qr_code_url: null,\n      created_at: now,\n      updated_at: now,\n    };\n\n    await this.db\n      .prepare(`\n        INSERT INTO stations (id, name, type, location, description, qr_code_url, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `)\n      .bind(\n        station.id,\n        station.name,\n        station.type,\n        station.location,\n        station.description,\n        station.qr_code_url,\n        station.created_at,\n        station.updated_at\n      )\n      .run();\n\n    return station;\n  }\n\n\n  /**\n   * Update an existing station\n   * Requirements: 1.3, 5.3, 7.5\n   */\n  async update(id: string, input: UpdateStationInput): Promise<Station | null> {\n    // First check if station exists\n    const existing = await this.getById(id);\n    if (!existing) {\n      return null;\n    }\n\n    const now = getCurrentTimestamp();\n    \n    // Build update fields\n    const updates: string[] = [];\n    const values: (string | null)[] = [];\n\n    if (input.name !== undefined) {\n      updates.push('name = ?');\n      values.push(input.name);\n    }\n    if (input.type !== undefined) {\n      updates.push('type = ?');\n      values.push(input.type);\n    }\n    if (input.location !== undefined) {\n      updates.push('location = ?');\n      values.push(input.location ?? null);\n    }\n    if (input.description !== undefined) {\n      updates.push('description = ?');\n      values.push(input.description ?? null);\n    }\n\n    // Always update updated_at\n    updates.push('updated_at = ?');\n    values.push(now);\n\n    // Add id for WHERE clause\n    values.push(id);\n\n    await this.db\n      .prepare(`UPDATE stations SET ${updates.join(', ')} WHERE id = ?`)\n      .bind(...values)\n      .run();\n\n    // Return updated station\n    return this.getById(id);\n  }\n\n  /**\n   * Delete a station and associated detection rules\n   * Requirements: 1.4, 5.4\n   */\n  async delete(id: string): Promise<boolean> {\n    // Check if station exists\n    const existing = await this.getById(id);\n    if (!existing) {\n      return false;\n    }\n\n    // Delete station (detection_rules will cascade delete due to FK constraint)\n    await this.db\n      .prepare('DELETE FROM stations WHERE id = ?')\n      .bind(id)\n      .run();\n\n    return true;\n  }\n\n  /**\n   * Check if a station exists\n   */\n  async exists(id: string): Promise<boolean> {\n    const result = await this.db\n      .prepare('SELECT 1 FROM stations WHERE id = ? LIMIT 1')\n      .bind(id)\n      .first();\n    \n    return result !== null;\n  }\n}\n", "/**\n * HeySalad QC - Detection Log Repository\n * \n * Implements create and query operations for detection_logs table.\n * Supports filtering by station_id with limit.\n * Requirements: 3.5\n */\n\nimport type { DetectionLogEntry, DetectedObject } from '../types';\nimport { generateUUID, getCurrentTimestamp } from './station-repository';\n\n/**\n * Default limit for log queries\n */\nconst DEFAULT_LIMIT = 20;\n\n/**\n * Input for creating a detection log entry\n */\nexport interface CreateDetectionLogInput {\n  station_id: string;\n  detected_items: DetectedObject[];\n  confidence_scores: Record<string, number>;\n  pass_fail: 'pass' | 'fail';\n  image_url?: string | null;\n}\n\n/**\n * Detection log repository for D1 database operations\n */\nexport class DetectionLogRepository {\n  private db: D1Database;\n\n  constructor(db: D1Database) {\n    this.db = db;\n  }\n\n  /**\n   * Get detection logs for a station with optional limit\n   * Requirements: 3.5, 5.7\n   * \n   * @param stationId - The station ID to filter by\n   * @param limit - Maximum number of logs to return (default 20)\n   * @returns Array of detection log entries, ordered by timestamp descending\n   */\n  async getByStationId(stationId: string, limit: number = DEFAULT_LIMIT): Promise<DetectionLogEntry[]> {\n    const result = await this.db\n      .prepare(`\n        SELECT * FROM detection_logs \n        WHERE station_id = ? \n        ORDER BY timestamp DESC \n        LIMIT ?\n      `)\n      .bind(stationId, limit)\n      .all<{\n        id: string;\n        station_id: string;\n        detected_items: string;\n        confidence_scores: string | null;\n        pass_fail: 'pass' | 'fail';\n        image_url: string | null;\n        timestamp: string;\n      }>();\n\n    return (result.results || []).map(row => this.parseDetectionLogRow(row));\n  }\n\n  /**\n   * Get a single detection log by ID\n   */\n  async getById(id: string): Promise<DetectionLogEntry | null> {\n    const result = await this.db\n      .prepare('SELECT * FROM detection_logs WHERE id = ?')\n      .bind(id)\n      .first<{\n        id: string;\n        station_id: string;\n        detected_items: string;\n        confidence_scores: string | null;\n        pass_fail: 'pass' | 'fail';\n        image_url: string | null;\n        timestamp: string;\n      }>();\n\n    if (!result) {\n      return null;\n    }\n\n    return this.parseDetectionLogRow(result);\n  }\n\n  /**\n   * Create a new detection log entry\n   * Requirements: 3.5\n   */\n  async create(input: CreateDetectionLogInput): Promise<DetectionLogEntry> {\n    const id = generateUUID();\n    const now = getCurrentTimestamp();\n\n    await this.db\n      .prepare(`\n        INSERT INTO detection_logs (id, station_id, detected_items, confidence_scores, pass_fail, image_url, timestamp)\n        VALUES (?, ?, ?, ?, ?, ?, ?)\n      `)\n      .bind(\n        id,\n        input.station_id,\n        JSON.stringify(input.detected_items),\n        JSON.stringify(input.confidence_scores),\n        input.pass_fail,\n        input.image_url ?? null,\n        now\n      )\n      .run();\n\n    return {\n      id,\n      station_id: input.station_id,\n      detected_items: input.detected_items,\n      confidence_scores: input.confidence_scores,\n      pass_fail: input.pass_fail,\n      image_url: input.image_url ?? null,\n      timestamp: now\n    };\n  }\n\n  /**\n   * Delete all detection logs for a station\n   */\n  async deleteByStationId(stationId: string): Promise<number> {\n    const result = await this.db\n      .prepare('DELETE FROM detection_logs WHERE station_id = ?')\n      .bind(stationId)\n      .run();\n\n    return result.meta.changes ?? 0;\n  }\n\n  /**\n   * Count detection logs for a station\n   */\n  async countByStationId(stationId: string): Promise<number> {\n    const result = await this.db\n      .prepare('SELECT COUNT(*) as count FROM detection_logs WHERE station_id = ?')\n      .bind(stationId)\n      .first<{ count: number }>();\n\n    return result?.count ?? 0;\n  }\n\n  /**\n   * Parse a database row into a DetectionLogEntry object\n   */\n  private parseDetectionLogRow(row: {\n    id: string;\n    station_id: string;\n    detected_items: string;\n    confidence_scores: string | null;\n    pass_fail: 'pass' | 'fail';\n    image_url: string | null;\n    timestamp: string;\n  }): DetectionLogEntry {\n    let detectedItems: DetectedObject[] = [];\n    let confidenceScores: Record<string, number> = {};\n\n    try {\n      detectedItems = JSON.parse(row.detected_items);\n    } catch {\n      detectedItems = [];\n    }\n\n    try {\n      if (row.confidence_scores) {\n        confidenceScores = JSON.parse(row.confidence_scores);\n      }\n    } catch {\n      confidenceScores = {};\n    }\n\n    return {\n      id: row.id,\n      station_id: row.station_id,\n      detected_items: detectedItems,\n      confidence_scores: confidenceScores,\n      pass_fail: row.pass_fail,\n      image_url: row.image_url,\n      timestamp: row.timestamp\n    };\n  }\n}\n", "/**\n * HeySalad QC - Detection Rules Repository\n * \n * Implements CRUD operations for detection_rules table using D1 database.\n * Handles JSON serialization for expected_items and alert_config.\n * Requirements: 4.6\n */\n\nimport type { DetectionRules, DetectionRulesInput, ExpectedItem, AlertConfig } from '../types';\nimport { generateUUID, getCurrentTimestamp } from './station-repository';\n\n/**\n * Default alert configuration\n */\nconst DEFAULT_ALERT_CONFIG: AlertConfig = {\n  enabled: false,\n  triggers: []\n};\n\n/**\n * Default confidence threshold\n */\nconst DEFAULT_CONFIDENCE_THRESHOLD = 0.75;\n\n/**\n * Detection rules repository for D1 database operations\n */\nexport class DetectionRulesRepository {\n  private db: D1Database;\n\n  constructor(db: D1Database) {\n    this.db = db;\n  }\n\n  /**\n   * Get detection rules for a station\n   * Requirements: 5.8\n   */\n  async getByStationId(stationId: string): Promise<DetectionRules | null> {\n    const result = await this.db\n      .prepare('SELECT * FROM detection_rules WHERE station_id = ?')\n      .bind(stationId)\n      .first<{\n        id: string;\n        station_id: string;\n        expected_items: string;\n        confidence_threshold: number;\n        alert_config: string | null;\n        created_at: string;\n      }>();\n\n    if (!result) {\n      return null;\n    }\n\n    return this.parseDetectionRulesRow(result);\n  }\n\n  /**\n   * Create detection rules for a station\n   * Requirements: 4.6\n   */\n  async create(stationId: string, input: DetectionRulesInput): Promise<DetectionRules> {\n    const id = generateUUID();\n    const now = getCurrentTimestamp();\n\n    const expectedItems = input.expected_items;\n    const confidenceThreshold = input.confidence_threshold ?? DEFAULT_CONFIDENCE_THRESHOLD;\n    const alertConfig = input.alert_config ?? DEFAULT_ALERT_CONFIG;\n\n    await this.db\n      .prepare(`\n        INSERT INTO detection_rules (id, station_id, expected_items, confidence_threshold, alert_config, created_at)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `)\n      .bind(\n        id,\n        stationId,\n        JSON.stringify(expectedItems),\n        confidenceThreshold,\n        JSON.stringify(alertConfig),\n        now\n      )\n      .run();\n\n    return {\n      id,\n      station_id: stationId,\n      expected_items: expectedItems,\n      confidence_threshold: confidenceThreshold,\n      alert_config: alertConfig,\n      created_at: now\n    };\n  }\n\n  /**\n   * Update detection rules for a station (upsert)\n   * Requirements: 5.8\n   */\n  async upsert(stationId: string, input: DetectionRulesInput): Promise<DetectionRules> {\n    const existing = await this.getByStationId(stationId);\n\n    if (existing) {\n      return this.update(stationId, input);\n    } else {\n      return this.create(stationId, input);\n    }\n  }\n\n  /**\n   * Update existing detection rules\n   * Requirements: 5.8\n   */\n  async update(stationId: string, input: DetectionRulesInput): Promise<DetectionRules> {\n    const existing = await this.getByStationId(stationId);\n    \n    if (!existing) {\n      throw new Error(`Detection rules not found for station ${stationId}`);\n    }\n\n    const expectedItems = input.expected_items;\n    const confidenceThreshold = input.confidence_threshold ?? existing.confidence_threshold;\n    const alertConfig = input.alert_config ?? existing.alert_config;\n\n    await this.db\n      .prepare(`\n        UPDATE detection_rules \n        SET expected_items = ?, confidence_threshold = ?, alert_config = ?\n        WHERE station_id = ?\n      `)\n      .bind(\n        JSON.stringify(expectedItems),\n        confidenceThreshold,\n        JSON.stringify(alertConfig),\n        stationId\n      )\n      .run();\n\n    return {\n      ...existing,\n      expected_items: expectedItems,\n      confidence_threshold: confidenceThreshold,\n      alert_config: alertConfig\n    };\n  }\n\n  /**\n   * Delete detection rules for a station\n   */\n  async delete(stationId: string): Promise<boolean> {\n    const existing = await this.getByStationId(stationId);\n    if (!existing) {\n      return false;\n    }\n\n    await this.db\n      .prepare('DELETE FROM detection_rules WHERE station_id = ?')\n      .bind(stationId)\n      .run();\n\n    return true;\n  }\n\n  /**\n   * Parse a database row into a DetectionRules object\n   */\n  private parseDetectionRulesRow(row: {\n    id: string;\n    station_id: string;\n    expected_items: string;\n    confidence_threshold: number;\n    alert_config: string | null;\n    created_at: string;\n  }): DetectionRules {\n    let expectedItems: ExpectedItem[] = [];\n    let alertConfig: AlertConfig = DEFAULT_ALERT_CONFIG;\n\n    try {\n      expectedItems = JSON.parse(row.expected_items);\n    } catch {\n      expectedItems = [];\n    }\n\n    try {\n      if (row.alert_config) {\n        alertConfig = JSON.parse(row.alert_config);\n      }\n    } catch {\n      alertConfig = DEFAULT_ALERT_CONFIG;\n    }\n\n    return {\n      id: row.id,\n      station_id: row.station_id,\n      expected_items: expectedItems,\n      confidence_threshold: row.confidence_threshold,\n      alert_config: alertConfig,\n      created_at: row.created_at\n    };\n  }\n}\n", "/**\n * HeySalad QC - Validation Utility Functions\n * \n * Implements validation for station inputs, detection rules, and UUIDs.\n * Requirements: 4.2, 8.3\n */\n\nimport type { StationType } from '../types';\n\n// =============================================================================\n// Validation Result Types\n// =============================================================================\n\nexport interface ValidationResult {\n  valid: boolean;\n  errors: string[];\n}\n\n// =============================================================================\n// Constants\n// =============================================================================\n\nconst VALID_STATION_TYPES: StationType[] = ['packing', 'prep', 'storage', 'receiving'];\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n\nconst STATION_VALIDATION = {\n  name: { minLength: 1, maxLength: 100 },\n  location: { maxLength: 200 },\n  description: { maxLength: 500 },\n};\n\n// =============================================================================\n// UUID Validation\n// =============================================================================\n\n/**\n * Validates a UUID string format\n * @param uuid - The string to validate\n * @returns true if valid UUID format, false otherwise\n */\nexport function isValidUUID(uuid: string): boolean {\n  if (typeof uuid !== 'string') return false;\n  return UUID_REGEX.test(uuid);\n}\n\n// =============================================================================\n// Station Validation\n// =============================================================================\n\n/**\n * Validates a station type value\n * @param type - The type to validate\n * @returns true if valid station type\n */\nexport function isValidStationType(type: unknown): type is StationType {\n  return typeof type === 'string' && VALID_STATION_TYPES.includes(type as StationType);\n}\n\n\n/**\n * Validates station name\n * @param name - The name to validate\n * @returns ValidationResult with errors if invalid\n */\nexport function validateStationName(name: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (name === undefined || name === null) {\n    errors.push('Name is required');\n  } else if (typeof name !== 'string') {\n    errors.push('Name must be a string');\n  } else {\n    const trimmed = name.trim();\n    if (trimmed.length < STATION_VALIDATION.name.minLength) {\n      errors.push(`Name must be at least ${STATION_VALIDATION.name.minLength} character(s)`);\n    }\n    if (trimmed.length > STATION_VALIDATION.name.maxLength) {\n      errors.push(`Name must be at most ${STATION_VALIDATION.name.maxLength} characters`);\n    }\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Validates optional station location\n * @param location - The location to validate\n * @returns ValidationResult with errors if invalid\n */\nexport function validateStationLocation(location: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (location !== undefined && location !== null) {\n    if (typeof location !== 'string') {\n      errors.push('Location must be a string');\n    } else if (location.length > STATION_VALIDATION.location.maxLength) {\n      errors.push(`Location must be at most ${STATION_VALIDATION.location.maxLength} characters`);\n    }\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Validates optional station description\n * @param description - The description to validate\n * @returns ValidationResult with errors if invalid\n */\nexport function validateStationDescription(description: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (description !== undefined && description !== null) {\n    if (typeof description !== 'string') {\n      errors.push('Description must be a string');\n    } else if (description.length > STATION_VALIDATION.description.maxLength) {\n      errors.push(`Description must be at most ${STATION_VALIDATION.description.maxLength} characters`);\n    }\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Validates a CreateStationInput object\n * @param input - The input to validate\n * @returns ValidationResult with all errors\n */\nexport function validateCreateStationInput(input: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (!input || typeof input !== 'object') {\n    return { valid: false, errors: ['Input must be an object'] };\n  }\n  \n  const data = input as Record<string, unknown>;\n  \n  // Validate name (required)\n  const nameResult = validateStationName(data.name);\n  errors.push(...nameResult.errors);\n  \n  // Validate type (required)\n  if (data.type === undefined || data.type === null) {\n    errors.push('Type is required');\n  } else if (!isValidStationType(data.type)) {\n    errors.push(`Type must be one of: ${VALID_STATION_TYPES.join(', ')}`);\n  }\n  \n  // Validate location (optional)\n  const locationResult = validateStationLocation(data.location);\n  errors.push(...locationResult.errors);\n  \n  // Validate description (optional)\n  const descriptionResult = validateStationDescription(data.description);\n  errors.push(...descriptionResult.errors);\n  \n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Validates an UpdateStationInput object\n * @param input - The input to validate\n * @returns ValidationResult with all errors\n */\nexport function validateUpdateStationInput(input: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (!input || typeof input !== 'object') {\n    return { valid: false, errors: ['Input must be an object'] };\n  }\n  \n  const data = input as Record<string, unknown>;\n  \n  // Validate name (optional for update)\n  if (data.name !== undefined) {\n    const nameResult = validateStationName(data.name);\n    errors.push(...nameResult.errors);\n  }\n  \n  // Validate type (optional for update)\n  if (data.type !== undefined && !isValidStationType(data.type)) {\n    errors.push(`Type must be one of: ${VALID_STATION_TYPES.join(', ')}`);\n  }\n  \n  // Validate location (optional)\n  const locationResult = validateStationLocation(data.location);\n  errors.push(...locationResult.errors);\n  \n  // Validate description (optional)\n  const descriptionResult = validateStationDescription(data.description);\n  errors.push(...descriptionResult.errors);\n  \n  return { valid: errors.length === 0, errors };\n}\n\n\n// =============================================================================\n// Confidence Threshold Validation (Requirements 4.2)\n// =============================================================================\n\n/**\n * Validates a confidence threshold value\n * Must be a number between 0.0 and 1.0 inclusive\n * @param threshold - The threshold value to validate\n * @returns true if valid, false otherwise\n */\nexport function isValidConfidenceThreshold(threshold: unknown): boolean {\n  if (typeof threshold !== 'number') return false;\n  if (Number.isNaN(threshold)) return false;\n  return threshold >= 0.0 && threshold <= 1.0;\n}\n\n/**\n * Validates a confidence threshold with detailed result\n * @param threshold - The threshold value to validate\n * @returns ValidationResult with errors if invalid\n */\nexport function validateConfidenceThreshold(threshold: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (threshold === undefined || threshold === null) {\n    // Threshold is optional, default will be applied\n    return { valid: true, errors: [] };\n  }\n  \n  if (typeof threshold !== 'number') {\n    errors.push('Confidence threshold must be a number');\n  } else if (Number.isNaN(threshold)) {\n    errors.push('Confidence threshold cannot be NaN');\n  } else if (threshold < 0.0) {\n    errors.push('Confidence threshold must be at least 0.0');\n  } else if (threshold > 1.0) {\n    errors.push('Confidence threshold must be at most 1.0');\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\n// =============================================================================\n// Expected Item Validation\n// =============================================================================\n\n/**\n * Validates an expected item object\n * @param item - The item to validate\n * @returns ValidationResult with errors if invalid\n */\nexport function validateExpectedItem(item: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (!item || typeof item !== 'object') {\n    return { valid: false, errors: ['Expected item must be an object'] };\n  }\n  \n  const data = item as Record<string, unknown>;\n  \n  // Validate label (required)\n  if (data.label === undefined || data.label === null) {\n    errors.push('Expected item label is required');\n  } else if (typeof data.label !== 'string') {\n    errors.push('Expected item label must be a string');\n  } else if (data.label.trim().length === 0) {\n    errors.push('Expected item label cannot be empty');\n  }\n  \n  // Validate required (required boolean)\n  if (data.required === undefined || data.required === null) {\n    errors.push('Expected item required field is required');\n  } else if (typeof data.required !== 'boolean') {\n    errors.push('Expected item required must be a boolean');\n  }\n  \n  // Validate min_confidence (optional)\n  if (data.min_confidence !== undefined && data.min_confidence !== null) {\n    if (!isValidConfidenceThreshold(data.min_confidence)) {\n      errors.push('Expected item min_confidence must be a number between 0.0 and 1.0');\n    }\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\n// =============================================================================\n// Alert Config Validation\n// =============================================================================\n\nconst VALID_ALERT_TRIGGERS = ['missing_item', 'low_confidence', 'all_failures'];\n\n/**\n * Validates an alert configuration object\n * @param config - The config to validate\n * @returns ValidationResult with errors if invalid\n */\nexport function validateAlertConfig(config: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (config === undefined || config === null) {\n    return { valid: true, errors: [] };\n  }\n  \n  if (typeof config !== 'object') {\n    return { valid: false, errors: ['Alert config must be an object'] };\n  }\n  \n  const data = config as Record<string, unknown>;\n  \n  // Validate enabled (required)\n  if (data.enabled === undefined || data.enabled === null) {\n    errors.push('Alert config enabled field is required');\n  } else if (typeof data.enabled !== 'boolean') {\n    errors.push('Alert config enabled must be a boolean');\n  }\n  \n  // Validate email (optional)\n  if (data.email !== undefined && data.email !== null && typeof data.email !== 'string') {\n    errors.push('Alert config email must be a string');\n  }\n  \n  // Validate slack_webhook (optional)\n  if (data.slack_webhook !== undefined && data.slack_webhook !== null && typeof data.slack_webhook !== 'string') {\n    errors.push('Alert config slack_webhook must be a string');\n  }\n  \n  // Validate sms (optional)\n  if (data.sms !== undefined && data.sms !== null && typeof data.sms !== 'string') {\n    errors.push('Alert config sms must be a string');\n  }\n  \n  // Validate triggers (required array)\n  if (data.triggers === undefined || data.triggers === null) {\n    errors.push('Alert config triggers is required');\n  } else if (!Array.isArray(data.triggers)) {\n    errors.push('Alert config triggers must be an array');\n  } else {\n    for (const trigger of data.triggers) {\n      if (!VALID_ALERT_TRIGGERS.includes(trigger as string)) {\n        errors.push(`Invalid alert trigger: ${trigger}. Must be one of: ${VALID_ALERT_TRIGGERS.join(', ')}`);\n      }\n    }\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n\n// =============================================================================\n// Detection Rules Validation\n// =============================================================================\n\n/**\n * Validates a DetectionRulesInput object\n * @param input - The input to validate\n * @returns ValidationResult with all errors\n */\nexport function validateDetectionRulesInput(input: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (!input || typeof input !== 'object') {\n    return { valid: false, errors: ['Input must be an object'] };\n  }\n  \n  const data = input as Record<string, unknown>;\n  \n  // Validate expected_items (required array)\n  if (data.expected_items === undefined || data.expected_items === null) {\n    errors.push('Expected items is required');\n  } else if (!Array.isArray(data.expected_items)) {\n    errors.push('Expected items must be an array');\n  } else {\n    for (let i = 0; i < data.expected_items.length; i++) {\n      const itemResult = validateExpectedItem(data.expected_items[i]);\n      for (const error of itemResult.errors) {\n        errors.push(`Expected item [${i}]: ${error}`);\n      }\n    }\n  }\n  \n  // Validate confidence_threshold (optional)\n  const thresholdResult = validateConfidenceThreshold(data.confidence_threshold);\n  errors.push(...thresholdResult.errors);\n  \n  // Validate alert_config (optional)\n  const alertResult = validateAlertConfig(data.alert_config);\n  errors.push(...alertResult.errors);\n  \n  return { valid: errors.length === 0, errors };\n}\n\n\n// =============================================================================\n// Detection Request Validation (Requirements 5.6, 8.3)\n// =============================================================================\n\n/**\n * Validates a DetectionRequest object\n * @param input - The input to validate\n * @returns ValidationResult with all errors\n */\nexport function validateDetectionRequest(input: unknown): ValidationResult {\n  const errors: string[] = [];\n  \n  if (!input || typeof input !== 'object') {\n    return { valid: false, errors: ['Input must be an object'] };\n  }\n  \n  const data = input as Record<string, unknown>;\n  \n  // Validate station_id (required)\n  if (data.station_id === undefined || data.station_id === null) {\n    errors.push('station_id is required');\n  } else if (typeof data.station_id !== 'string') {\n    errors.push('station_id must be a string');\n  } else if (data.station_id.trim().length === 0) {\n    errors.push('station_id cannot be empty');\n  }\n  \n  // Validate image_data (required)\n  if (data.image_data === undefined || data.image_data === null) {\n    errors.push('image_data is required');\n  } else if (typeof data.image_data !== 'string') {\n    errors.push('image_data must be a string');\n  }\n  \n  return { valid: errors.length === 0, errors };\n}\n", "/**\n * HeySalad QC - Checklist Comparison Logic\n * \n * Compares expected items vs detected items.\n * Marks items as found/missing based on presence.\n * Flags failures for missing required items.\n * Requirements: 3.4, 4.3\n */\n\nimport type { ExpectedItem, DetectedObject } from '../types';\n\n/**\n * Result of comparing a single expected item against detected items\n */\nexport interface ChecklistItemResult {\n  label: string;\n  required: boolean;\n  found: boolean;\n  confidence: number | null;\n}\n\n/**\n * Overall checklist comparison result\n */\nexport interface ChecklistResult {\n  items: ChecklistItemResult[];\n  found: string[];\n  missing: string[];\n  pass: boolean;\n}\n\n/**\n * Compares expected items against detected items to produce a checklist result.\n * \n * An item is considered \"found\" if it appears in both expected and detected sets.\n * An item is considered \"missing\" if it appears in expected but not in detected.\n * The overall result is \"pass\" only if all required items are found.\n * \n * Requirements: 3.4, 4.3\n * \n * @param expectedItems - Array of expected items with labels and required flags\n * @param detectedObjects - Array of detected objects with labels and confidence scores\n * @param confidenceThreshold - Minimum confidence required to consider an item detected (default 0.0)\n * @returns ChecklistResult with found/missing items and pass/fail status\n */\nexport function compareChecklist(\n  expectedItems: ExpectedItem[],\n  detectedObjects: DetectedObject[],\n  confidenceThreshold: number = 0.0\n): ChecklistResult {\n  // Build a map of detected labels to their highest confidence score\n  const detectedMap = new Map<string, number>();\n  for (const obj of detectedObjects) {\n    const normalizedLabel = obj.label.toLowerCase().trim();\n    const existingConfidence = detectedMap.get(normalizedLabel) ?? 0;\n    if (obj.confidence > existingConfidence) {\n      detectedMap.set(normalizedLabel, obj.confidence);\n    }\n  }\n\n  const items: ChecklistItemResult[] = [];\n  const found: string[] = [];\n  const missing: string[] = [];\n  let allRequiredFound = true;\n\n  for (const expected of expectedItems) {\n    const normalizedLabel = expected.label.toLowerCase().trim();\n    const detectedConfidence = detectedMap.get(normalizedLabel);\n    \n    // Item is found if it exists in detected set AND meets confidence threshold\n    const itemFound = detectedConfidence !== undefined && detectedConfidence >= confidenceThreshold;\n    \n    items.push({\n      label: expected.label,\n      required: expected.required,\n      found: itemFound,\n      confidence: detectedConfidence ?? null\n    });\n\n    if (itemFound) {\n      found.push(expected.label);\n    } else {\n      missing.push(expected.label);\n      // If a required item is missing, the overall check fails\n      if (expected.required) {\n        allRequiredFound = false;\n      }\n    }\n  }\n\n  return {\n    items,\n    found,\n    missing,\n    pass: allRequiredFound\n  };\n}\n\n/**\n * Simple comparison of expected labels vs detected labels.\n * Returns found and missing arrays.\n * \n * @param expectedLabels - Array of expected item labels\n * @param detectedLabels - Array of detected item labels\n * @returns Object with found and missing arrays\n */\nexport function compareLabels(\n  expectedLabels: string[],\n  detectedLabels: string[]\n): { found: string[]; missing: string[] } {\n  const detectedSet = new Set(detectedLabels.map(l => l.toLowerCase().trim()));\n  \n  const found: string[] = [];\n  const missing: string[] = [];\n\n  for (const label of expectedLabels) {\n    const normalizedLabel = label.toLowerCase().trim();\n    if (detectedSet.has(normalizedLabel)) {\n      found.push(label);\n    } else {\n      missing.push(label);\n    }\n  }\n\n  return { found, missing };\n}\n", "/**\n * HeySalad QC - Mock Detection Processor\n * \n * Generates mock detection results for testing.\n * Returns DetectionResult with detected_objects, pass/fail status.\n * Requirements: 3.6\n */\n\nimport type { DetectionResult, DetectedObject, ExpectedItem, BoundingBox } from '../types';\nimport { compareChecklist } from './checklist';\n\nconst MOCK_DETECTABLE_ITEMS = [\n  'lettuce', 'tomato', 'cucumber', 'onion', 'carrot', 'chicken',\n  'beef', 'tofu', 'cheese', 'dressing', 'croutons', 'bacon',\n  'egg', 'avocado', 'pepper', 'salt', 'napkin', 'fork',\n  'knife', 'container', 'lid', 'label'\n];\n\nfunction generateRandomBbox(): BoundingBox {\n  const x = Math.floor(Math.random() * 500);\n  const y = Math.floor(Math.random() * 400);\n  const width = Math.floor(Math.random() * 100) + 50;\n  const height = Math.floor(Math.random() * 100) + 50;\n  return [x, y, width, height];\n}\n\nfunction generateRandomConfidence(): number {\n  return 0.5 + Math.random() * 0.5;\n}\n\nexport function generateMockDetectedObjects(\n  expectedItems: ExpectedItem[],\n  detectionRate: number = 0.8\n): DetectedObject[] {\n  const detected: DetectedObject[] = [];\n  for (const item of expectedItems) {\n    if (Math.random() < detectionRate) {\n      detected.push({\n        label: item.label,\n        confidence: generateRandomConfidence(),\n        bbox: generateRandomBbox()\n      });\n    }\n  }\n  if (Math.random() < 0.3) {\n    const randomItem = MOCK_DETECTABLE_ITEMS[Math.floor(Math.random() * MOCK_DETECTABLE_ITEMS.length)];\n    const alreadyDetected = detected.some(d => d.label.toLowerCase() === randomItem.toLowerCase());\n    if (!alreadyDetected) {\n      detected.push({\n        label: randomItem,\n        confidence: generateRandomConfidence(),\n        bbox: generateRandomBbox()\n      });\n    }\n  }\n  return detected;\n}\n\nexport function processMockDetection(\n  expectedItems: ExpectedItem[],\n  confidenceThreshold: number = 0.75,\n  detectionRate: number = 0.8\n): DetectionResult {\n  const detectedObjects = generateMockDetectedObjects(expectedItems, detectionRate);\n  const checklistResult = compareChecklist(expectedItems, detectedObjects, confidenceThreshold);\n  return {\n    detected_objects: detectedObjects,\n    expected_objects: expectedItems.map(item => item.label),\n    timestamp: new Date().toISOString(),\n    pass: checklistResult.pass,\n    missing: checklistResult.missing\n  };\n}\n\nexport function processDeterministicDetection(\n  expectedItems: ExpectedItem[]\n): DetectionResult {\n  const detectedObjects: DetectedObject[] = expectedItems.map((item, index) => ({\n    label: item.label,\n    confidence: 0.95,\n    bbox: [index * 100, index * 80, 80, 60] as BoundingBox\n  }));\n  return {\n    detected_objects: detectedObjects,\n    expected_objects: expectedItems.map(item => item.label),\n    timestamp: new Date().toISOString(),\n    pass: true,\n    missing: []\n  };\n}\n\nexport function processFailingDetection(\n  expectedItems: ExpectedItem[]\n): DetectionResult {\n  const hasRequiredItems = expectedItems.some(item => item.required);\n  return {\n    detected_objects: [],\n    expected_objects: expectedItems.map(item => item.label),\n    timestamp: new Date().toISOString(),\n    pass: !hasRequiredItems,\n    missing: expectedItems.map(item => item.label)\n  };\n}\n", "/**\n * HeySalad QC - Cloudflare Worker Entry Point\n * \n * This worker handles API requests for the HeySalad QC application.\n * It connects to D1 database for data storage and R2 for PDF file storage.\n */\n\nimport type { Env, DetectionRequest } from './types';\nimport { StationRepository } from './lib/station-repository';\nimport { DetectionLogRepository } from './lib/detection-log-repository';\nimport { DetectionRulesRepository } from './lib/detection-rules-repository';\nimport { validateCreateStationInput, validateUpdateStationInput, validateDetectionRulesInput, isValidUUID, validateDetectionRequest } from './lib/validation';\nimport { processMockDetection } from './lib/mock-detection';\n\n// CORS headers helper\nfunction corsHeaders(origin: string, allowedOrigins: string): HeadersInit {\n  const origins = allowedOrigins.split(',').map(o => o.trim());\n  const allowOrigin = origins.includes(origin) ? origin : origins[0];\n  \n  return {\n    'Access-Control-Allow-Origin': allowOrigin,\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type',\n  };\n}\n\n// Handle CORS preflight requests\nfunction handleOptions(request: Request, env: Env): Response {\n  const origin = request.headers.get('Origin') || '';\n  return new Response(null, {\n    status: 204,\n    headers: corsHeaders(origin, env.ALLOWED_ORIGINS),\n  });\n}\n\n// JSON response helper\nfunction jsonResponse(data: unknown, status = 200, origin = '', allowedOrigins = ''): Response {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    ...(allowedOrigins ? corsHeaders(origin, allowedOrigins) : {}),\n  };\n  \n  return new Response(JSON.stringify(data), { status, headers });\n}\n\n// Error response helper\nfunction errorResponse(message: string, status = 500, origin = '', allowedOrigins = ''): Response {\n  return jsonResponse({ error: message }, status, origin, allowedOrigins);\n}\n\n// Validation error response helper\nfunction validationErrorResponse(errors: string[], origin = '', allowedOrigins = ''): Response {\n  return jsonResponse({ error: 'VALIDATION_ERROR', message: 'Validation failed', errors }, 422, origin, allowedOrigins);\n}\n\nexport default {\n  async fetch(request: Request, env: Env, _ctx: ExecutionContext): Promise<Response> {\n    const url = new URL(request.url);\n    const origin = request.headers.get('Origin') || '';\n    \n    // Handle CORS preflight\n    if (request.method === 'OPTIONS') {\n      return handleOptions(request, env);\n    }\n    \n    // Initialize repository\n    const stationRepository = new StationRepository(env.DB);\n    \n    // API routes\n    if (url.pathname.startsWith('/api/')) {\n      try {\n        // Health check endpoint\n        if (url.pathname === '/api/health') {\n          return jsonResponse({ status: 'ok', timestamp: new Date().toISOString() }, 200, origin, env.ALLOWED_ORIGINS);\n        }\n        \n        // GET /api/stations - List all stations (Requirements 5.1)\n        if (url.pathname === '/api/stations' && request.method === 'GET') {\n          const stations = await stationRepository.list();\n          return jsonResponse(stations, 200, origin, env.ALLOWED_ORIGINS);\n        }\n        \n        // POST /api/stations - Create station (Requirements 5.2)\n        if (url.pathname === '/api/stations' && request.method === 'POST') {\n          let body: unknown;\n          try {\n            body = await request.json();\n          } catch {\n            return errorResponse('Invalid JSON', 400, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          const validation = validateCreateStationInput(body);\n          if (!validation.valid) {\n            return validationErrorResponse(validation.errors, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          const station = await stationRepository.create(body as { name: string; type: 'packing' | 'prep' | 'storage' | 'receiving'; location?: string; description?: string });\n          return jsonResponse(station, 201, origin, env.ALLOWED_ORIGINS);\n        }\n        \n        // Station by ID endpoints\n        const stationMatch = url.pathname.match(/^\\/api\\/stations\\/([^/]+)$/);\n        if (stationMatch) {\n          const stationId = stationMatch[1];\n          \n          // Validate UUID format\n          if (!isValidUUID(stationId)) {\n            return errorResponse('Invalid station ID format', 400, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // GET /api/stations/{id} - Get station by ID (Requirements 5.1)\n          if (request.method === 'GET') {\n            const station = await stationRepository.getById(stationId);\n            if (!station) {\n              return errorResponse('Station not found', 404, origin, env.ALLOWED_ORIGINS);\n            }\n            return jsonResponse(station, 200, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // PUT /api/stations/{id} - Update station (Requirements 5.3)\n          if (request.method === 'PUT') {\n            let body: unknown;\n            try {\n              body = await request.json();\n            } catch {\n              return errorResponse('Invalid JSON', 400, origin, env.ALLOWED_ORIGINS);\n            }\n            \n            const validation = validateUpdateStationInput(body);\n            if (!validation.valid) {\n              return validationErrorResponse(validation.errors, origin, env.ALLOWED_ORIGINS);\n            }\n            \n            const station = await stationRepository.update(stationId, body as { name?: string; type?: 'packing' | 'prep' | 'storage' | 'receiving'; location?: string; description?: string });\n            if (!station) {\n              return errorResponse('Station not found', 404, origin, env.ALLOWED_ORIGINS);\n            }\n            return jsonResponse(station, 200, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // DELETE /api/stations/{id} - Delete station (Requirements 5.4)\n          if (request.method === 'DELETE') {\n            const deleted = await stationRepository.delete(stationId);\n            if (!deleted) {\n              return errorResponse('Station not found', 404, origin, env.ALLOWED_ORIGINS);\n            }\n            return new Response(null, { \n              status: 204, \n              headers: corsHeaders(origin, env.ALLOWED_ORIGINS) \n            });\n          }\n        }\n        \n        // GET /api/stations/{id}/logs - Get detection logs for station (Requirements 5.7)\n        const logsMatch = url.pathname.match(/^\\/api\\/stations\\/([^/]+)\\/logs$/);\n        if (logsMatch && request.method === 'GET') {\n          const stationId = logsMatch[1];\n          \n          // Validate UUID format\n          if (!isValidUUID(stationId)) {\n            return errorResponse('Invalid station ID format', 400, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // Verify station exists\n          const station = await stationRepository.getById(stationId);\n          if (!station) {\n            return errorResponse('Station not found', 404, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // Get limit from query params (default 20)\n          const limitParam = url.searchParams.get('limit');\n          let limit = 20;\n          if (limitParam) {\n            const parsedLimit = parseInt(limitParam, 10);\n            if (!isNaN(parsedLimit) && parsedLimit > 0) {\n              limit = Math.min(parsedLimit, 100); // Cap at 100 for safety\n            }\n          }\n          \n          // Get detection logs\n          const detectionLogRepository = new DetectionLogRepository(env.DB);\n          const logs = await detectionLogRepository.getByStationId(stationId, limit);\n          \n          return jsonResponse(logs, 200, origin, env.ALLOWED_ORIGINS);\n        }\n        \n        // /api/stations/{id}/rules - Detection rules endpoints (Requirements 5.8)\n        const rulesMatch = url.pathname.match(/^\\/api\\/stations\\/([^/]+)\\/rules$/);\n        if (rulesMatch) {\n          const stationId = rulesMatch[1];\n          \n          // Validate UUID format\n          if (!isValidUUID(stationId)) {\n            return errorResponse('Invalid station ID format', 400, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // Verify station exists\n          const station = await stationRepository.getById(stationId);\n          if (!station) {\n            return errorResponse('Station not found', 404, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          const detectionRulesRepository = new DetectionRulesRepository(env.DB);\n          \n          // GET /api/stations/{id}/rules - Get detection rules for station\n          if (request.method === 'GET') {\n            const rules = await detectionRulesRepository.getByStationId(stationId);\n            return jsonResponse(rules, 200, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // PUT /api/stations/{id}/rules - Update detection rules for station\n          if (request.method === 'PUT') {\n            let body: unknown;\n            try {\n              body = await request.json();\n            } catch {\n              return errorResponse('Invalid JSON', 400, origin, env.ALLOWED_ORIGINS);\n            }\n            \n            const validation = validateDetectionRulesInput(body);\n            if (!validation.valid) {\n              return validationErrorResponse(validation.errors, origin, env.ALLOWED_ORIGINS);\n            }\n            \n            const rules = await detectionRulesRepository.upsert(\n              stationId, \n              body as { expected_items: Array<{ label: string; required: boolean; min_confidence?: number }>; confidence_threshold?: number; alert_config?: { enabled: boolean; email?: string; slack_webhook?: string; sms?: string; triggers: Array<'missing_item' | 'low_confidence' | 'all_failures'> } }\n            );\n            return jsonResponse(rules, 200, origin, env.ALLOWED_ORIGINS);\n          }\n        }\n        \n        // Note: PDF generation moved to client-side for better compatibility\n        // The /api/generate-mat endpoint is deprecated - use client-side mat-generator.ts instead\n        \n        // POST /api/detect - Process mock detection (Requirements 5.6)\n        if (url.pathname === '/api/detect' && request.method === 'POST') {\n          let body: unknown;\n          try {\n            body = await request.json();\n          } catch {\n            return errorResponse('Invalid JSON', 400, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // Validate request body\n          const validation = validateDetectionRequest(body);\n          if (!validation.valid) {\n            return validationErrorResponse(validation.errors, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          const { station_id: stationId } = body as DetectionRequest;\n          \n          // Validate station ID format\n          if (!isValidUUID(stationId)) {\n            return errorResponse('Invalid station ID format', 400, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // Verify station exists\n          const station = await stationRepository.getById(stationId);\n          if (!station) {\n            return errorResponse('Station not found', 404, origin, env.ALLOWED_ORIGINS);\n          }\n          \n          // Get detection rules for the station\n          const detectionRulesRepository = new DetectionRulesRepository(env.DB);\n          const rules = await detectionRulesRepository.getByStationId(stationId);\n          \n          // Use default values if no rules configured\n          const expectedItems = rules?.expected_items ?? [];\n          const confidenceThreshold = rules?.confidence_threshold ?? 0.75;\n          \n          // Process mock detection\n          const detectionResult = processMockDetection(expectedItems, confidenceThreshold);\n          \n          // Build confidence scores map from detected objects\n          const confidenceScores: Record<string, number> = {};\n          for (const obj of detectionResult.detected_objects) {\n            confidenceScores[obj.label] = obj.confidence;\n          }\n          \n          // Log the detection result\n          const detectionLogRepository = new DetectionLogRepository(env.DB);\n          await detectionLogRepository.create({\n            station_id: stationId,\n            detected_items: detectionResult.detected_objects,\n            confidence_scores: confidenceScores,\n            pass_fail: detectionResult.pass ? 'pass' : 'fail',\n            image_url: null // Mock detection doesn't store images\n          });\n          \n          return jsonResponse(detectionResult, 200, origin, env.ALLOWED_ORIGINS);\n        }\n        \n        return errorResponse('Not Found', 404, origin, env.ALLOWED_ORIGINS);\n      } catch (error) {\n        console.error('API Error:', error);\n        return errorResponse('Internal Server Error', 500, origin, env.ALLOWED_ORIGINS);\n      }\n    }\n    \n    // For non-API routes, return 404 (Pages will handle static files)\n    return errorResponse('Not Found', 404, origin, env.ALLOWED_ORIGINS);\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/chilumbam/heysalad-qc/src/worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/chilumbam/heysalad-qc/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/chilumbam/heysalad-qc/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/chilumbam/heysalad-qc/src/worker.ts\";\n\t\t\t\tconst MIDDLEWARE_TEST_INJECT = \"__INJECT_FOR_TESTING_WRANGLER_MIDDLEWARE__\";\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/chilumbam/heysalad-qc/.wrangler/tmp/bundle-jEFwqU/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/chilumbam/heysalad-qc/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/chilumbam/heysalad-qc/.wrangler/tmp/bundle-jEFwqU/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/chilumbam/heysalad-qc/.wrangler/tmp/bundle-jEFwqU/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
